#### hash 算法

设函数y = f(x)，它具有如下的特征：

1. x->∞
2. y->N，N很大，大概几百万，几千万，几亿，但是有限极大数
3. x,y都是正整数

通常来说，y符合单一性，那么问题

f(x)在x∈∞的情况下，y是否会相等，答案是必须的。

hash算法的定义就是一个通过算法将一个对象，通过某种函数（算法）映射为某种有限值y，在某个x∈D的数据域中 y是不会冲突的，但是超过D，那么y值重复的概率会越来越大，如果D超过了N，那么就是100%了，所以这个时候，两个输入值x对应的值y
冲突了，这就是哈希冲突，f(x)叫哈希函数。

#### 如何解决哈希冲突
[解决哈希冲突的常用方法分析](https://cloud.tencent.com/developer/article/1672781)
##### 1. 开放定址法
设y的长度为N，假设f(x)计算的的地址为M，M<N，如果M已经被占用了（冲突），那么从M地址开始，往后查找没被占用的
地址(K,K∈（M,N)来保存。
在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。
开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素

##### 1.1 线行探查法
> 线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止
##### 1.2 平方探查法
> 平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。
在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。
##### 1.3 双散列函数探查法
1. hash函数1，y1 = f1(x)
2. hash函数2，y2 = f2(x)

> 这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。

#### 2 链地址法（拉链法）
>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况
如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下

```
0       
1  -> 40 -> 27 -> 53 
2
3  -> 16 -> 42
4
5
6  -> 32 -> 71
7  -> 46
8
9
10 -> 36 -> 49
11 -> 24
12 -> 64
```
hashMap在java8中的红黑树是为了解决链表可能过长而提升查询的优化方法。
##### 3 再哈希法
1. hash1 = f(x);
2. hash2 = f(hash1);
一直，直到不同。就是同时构造多个不同的哈希函数
Hi = RHi(key)   i= 1,2,3 … k;
当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。
#### 4 建立公共溢出区
将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。
