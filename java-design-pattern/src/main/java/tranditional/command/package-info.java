package tranditional.command;
/**
 * 命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，
 * 传到了士兵耳朵里，士兵去执行。
 * 这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。
 *
 * 角色：
 *      司令员：invoker（命令调用者）
 *      士兵：receiver（命令执行者）
 *      命令：command的实现（命令本身），持有接受对象
 *
 *
 *
 * 可是，在实际开发过程中，封装不正是基于这种想法吗？将细节掩藏起来，只负责对外一个接口，实际上面向对象开发都是基于这个思想而来的，
 * 所以这个思想有什么特别的吗？命令模式存在我们每个接口调用的过程中，只是我们并如此明确的区分谁是命令者和接收者，但这种思想已经潜移默化
 * 中在我们的代码中显示出来了。
 *
 * ，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，
 * Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！
 *
 * 产品化的今天，命令模式也许是个很好的参考，在服务分化，将每个服务作为一个原子产品设计和封装，在通过权限设置，我们可以很好的复用这些
 * 代码，这是代码产品话过程中我们必须考虑的
 *
 **/